import React, { createContext, useContext, useState, createElement, useEffect, useLayoutEffect, useRef, useCallback, useDebugValue, useMemo } from "react";
/*! *****************************************************************************
Copyright (c) Microsoft Corporation.

Permission to use, copy, modify, and/or distribute this software for any
purpose with or without fee is hereby granted.

THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
PERFORMANCE OF THIS SOFTWARE.
***************************************************************************** */
function __awaiter(thisArg, _arguments, P, generator) {
  function adopt(value) {
    return value instanceof P ? value : new P(function(resolve) {
      resolve(value);
    });
  }
  return new (P || (P = Promise))(function(resolve, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    }
    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e) {
        reject(e);
      }
    }
    function step(result) {
      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
    }
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
}
function __generator(thisArg, body2) {
  var _ = { label: 0, sent: function() {
    if (t[0] & 1)
      throw t[1];
    return t[1];
  }, trys: [], ops: [] }, f, y, t, g;
  return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() {
    return this;
  }), g;
  function verb(n) {
    return function(v) {
      return step([n, v]);
    };
  }
  function step(op) {
    if (f)
      throw new TypeError("Generator is already executing.");
    while (_)
      try {
        if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done)
          return t;
        if (y = 0, t)
          op = [op[0] & 2, t.value];
        switch (op[0]) {
          case 0:
          case 1:
            t = op;
            break;
          case 4:
            _.label++;
            return { value: op[1], done: false };
          case 5:
            _.label++;
            y = op[1];
            op = [0];
            continue;
          case 7:
            op = _.ops.pop();
            _.trys.pop();
            continue;
          default:
            if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) {
              _ = 0;
              continue;
            }
            if (op[0] === 3 && (!t || op[1] > t[0] && op[1] < t[3])) {
              _.label = op[1];
              break;
            }
            if (op[0] === 6 && _.label < t[1]) {
              _.label = t[1];
              t = op;
              break;
            }
            if (t && _.label < t[2]) {
              _.label = t[2];
              _.ops.push(op);
              break;
            }
            if (t[2])
              _.ops.pop();
            _.trys.pop();
            continue;
        }
        op = body2.call(thisArg, _);
      } catch (e) {
        op = [6, e];
        y = 0;
      } finally {
        f = t = 0;
      }
    if (op[0] & 5)
      throw op[1];
    return { value: op[0] ? op[1] : void 0, done: true };
  }
}
var noop = function() {
};
var UNDEFINED = noop();
var OBJECT = Object;
var isUndefined = function(v) {
  return v === UNDEFINED;
};
var isFunction = function(v) {
  return typeof v == "function";
};
var mergeObjects = function(a, b) {
  return OBJECT.assign({}, a, b);
};
var STR_UNDEFINED = "undefined";
var hasWindow = function() {
  return typeof window != STR_UNDEFINED;
};
var hasDocument = function() {
  return typeof document != STR_UNDEFINED;
};
var hasRequestAnimationFrame = function() {
  return hasWindow() && typeof window["requestAnimationFrame"] != STR_UNDEFINED;
};
var table = /* @__PURE__ */ new WeakMap();
var counter = 0;
var stableHash = function(arg) {
  var type = typeof arg;
  var constructor = arg && arg.constructor;
  var isDate = constructor == Date;
  var result;
  var index;
  if (OBJECT(arg) === arg && !isDate && constructor != RegExp) {
    result = table.get(arg);
    if (result)
      return result;
    result = ++counter + "~";
    table.set(arg, result);
    if (constructor == Array) {
      result = "@";
      for (index = 0; index < arg.length; index++) {
        result += stableHash(arg[index]) + ",";
      }
      table.set(arg, result);
    }
    if (constructor == OBJECT) {
      result = "#";
      var keys = OBJECT.keys(arg).sort();
      while (!isUndefined(index = keys.pop())) {
        if (!isUndefined(arg[index])) {
          result += index + ":" + stableHash(arg[index]) + ",";
        }
      }
      table.set(arg, result);
    }
  } else {
    result = isDate ? arg.toJSON() : type == "symbol" ? arg.toString() : type == "string" ? JSON.stringify(arg) : "" + arg;
  }
  return result;
};
var online = true;
var isOnline = function() {
  return online;
};
var hasWin = hasWindow();
var hasDoc = hasDocument();
var onWindowEvent = hasWin && window.addEventListener ? window.addEventListener.bind(window) : noop;
var onDocumentEvent = hasDoc ? document.addEventListener.bind(document) : noop;
var offWindowEvent = hasWin && window.removeEventListener ? window.removeEventListener.bind(window) : noop;
var offDocumentEvent = hasDoc ? document.removeEventListener.bind(document) : noop;
var isVisible = function() {
  var visibilityState = hasDoc && document.visibilityState;
  return isUndefined(visibilityState) || visibilityState !== "hidden";
};
var initFocus = function(callback) {
  onDocumentEvent("visibilitychange", callback);
  onWindowEvent("focus", callback);
  return function() {
    offDocumentEvent("visibilitychange", callback);
    offWindowEvent("focus", callback);
  };
};
var initReconnect = function(callback) {
  var onOnline = function() {
    online = true;
    callback();
  };
  var onOffline = function() {
    online = false;
  };
  onWindowEvent("online", onOnline);
  onWindowEvent("offline", onOffline);
  return function() {
    offWindowEvent("online", onOnline);
    offWindowEvent("offline", onOffline);
  };
};
var preset = {
  isOnline,
  isVisible
};
var defaultConfigOptions = {
  initFocus,
  initReconnect
};
var IS_SERVER = !hasWindow() || "Deno" in window;
var rAF = function(f) {
  return hasRequestAnimationFrame() ? window["requestAnimationFrame"](f) : setTimeout(f, 1);
};
var useIsomorphicLayoutEffect = IS_SERVER ? useEffect : useLayoutEffect;
var navigatorConnection = typeof navigator !== "undefined" && navigator.connection;
var slowConnection = !IS_SERVER && navigatorConnection && (["slow-2g", "2g"].includes(navigatorConnection.effectiveType) || navigatorConnection.saveData);
var serialize = function(key) {
  if (isFunction(key)) {
    try {
      key = key();
    } catch (err) {
      key = "";
    }
  }
  var args = [].concat(key);
  key = typeof key == "string" ? key : (Array.isArray(key) ? key.length : key) ? stableHash(key) : "";
  var infoKey = key ? "$swr$" + key : "";
  return [key, args, infoKey];
};
var SWRGlobalState = /* @__PURE__ */ new WeakMap();
var FOCUS_EVENT = 0;
var RECONNECT_EVENT = 1;
var MUTATE_EVENT = 2;
var broadcastState = function(cache2, key, data, error, isValidating, revalidate, broadcast) {
  if (broadcast === void 0) {
    broadcast = true;
  }
  var _a2 = SWRGlobalState.get(cache2), EVENT_REVALIDATORS = _a2[0], STATE_UPDATERS = _a2[1], FETCH = _a2[3];
  var revalidators = EVENT_REVALIDATORS[key];
  var updaters = STATE_UPDATERS[key];
  if (broadcast && updaters) {
    for (var i = 0; i < updaters.length; ++i) {
      updaters[i](data, error, isValidating);
    }
  }
  if (revalidate) {
    delete FETCH[key];
    if (revalidators && revalidators[0]) {
      return revalidators[0](MUTATE_EVENT).then(function() {
        return cache2.get(key);
      });
    }
  }
  return cache2.get(key);
};
var __timestamp = 0;
var getTimestamp = function() {
  return ++__timestamp;
};
var internalMutate = function() {
  var args = [];
  for (var _i = 0; _i < arguments.length; _i++) {
    args[_i] = arguments[_i];
  }
  return __awaiter(void 0, void 0, void 0, function() {
    var cache2, _key, _data, _opts, options, populateCache, revalidate, rollbackOnError, customOptimisticData, _a2, key, keyInfo, _b, MUTATION, data, error, beforeMutationTs, hasCustomOptimisticData, rollbackData, optimisticData, res;
    return __generator(this, function(_c) {
      switch (_c.label) {
        case 0:
          cache2 = args[0], _key = args[1], _data = args[2], _opts = args[3];
          options = typeof _opts === "boolean" ? { revalidate: _opts } : _opts || {};
          populateCache = isUndefined(options.populateCache) ? true : options.populateCache;
          revalidate = options.revalidate !== false;
          rollbackOnError = options.rollbackOnError !== false;
          customOptimisticData = options.optimisticData;
          _a2 = serialize(_key), key = _a2[0], keyInfo = _a2[2];
          if (!key)
            return [2];
          _b = SWRGlobalState.get(cache2), MUTATION = _b[2];
          if (args.length < 3) {
            return [2, broadcastState(cache2, key, cache2.get(key), UNDEFINED, UNDEFINED, revalidate, true)];
          }
          data = _data;
          beforeMutationTs = getTimestamp();
          MUTATION[key] = [beforeMutationTs, 0];
          hasCustomOptimisticData = !isUndefined(customOptimisticData);
          rollbackData = cache2.get(key);
          if (hasCustomOptimisticData) {
            optimisticData = isFunction(customOptimisticData) ? customOptimisticData(rollbackData) : customOptimisticData;
            cache2.set(key, optimisticData);
            broadcastState(cache2, key, optimisticData);
          }
          if (isFunction(data)) {
            try {
              data = data(cache2.get(key));
            } catch (err) {
              error = err;
            }
          }
          if (!(data && isFunction(data.then)))
            return [3, 2];
          return [
            4,
            data.catch(function(err) {
              error = err;
            })
          ];
        case 1:
          data = _c.sent();
          if (beforeMutationTs !== MUTATION[key][0]) {
            if (error)
              throw error;
            return [2, data];
          } else if (error && hasCustomOptimisticData && rollbackOnError) {
            populateCache = true;
            data = rollbackData;
            cache2.set(key, rollbackData);
          }
          _c.label = 2;
        case 2:
          if (populateCache) {
            if (!error) {
              if (isFunction(populateCache)) {
                data = populateCache(data, rollbackData);
              }
              cache2.set(key, data);
            }
            cache2.set(keyInfo, mergeObjects(cache2.get(keyInfo), { error }));
          }
          MUTATION[key][1] = getTimestamp();
          return [
            4,
            broadcastState(cache2, key, data, error, UNDEFINED, revalidate, !!populateCache)
          ];
        case 3:
          res = _c.sent();
          if (error)
            throw error;
          return [2, populateCache ? res : data];
      }
    });
  });
};
var revalidateAllKeys = function(revalidators, type) {
  for (var key in revalidators) {
    if (revalidators[key][0])
      revalidators[key][0](type);
  }
};
var initCache = function(provider, options) {
  if (!SWRGlobalState.has(provider)) {
    var opts = mergeObjects(defaultConfigOptions, options);
    var EVENT_REVALIDATORS = {};
    var mutate2 = internalMutate.bind(UNDEFINED, provider);
    var unmount = noop;
    SWRGlobalState.set(provider, [EVENT_REVALIDATORS, {}, {}, {}, mutate2]);
    if (!IS_SERVER) {
      var releaseFocus_1 = opts.initFocus(setTimeout.bind(UNDEFINED, revalidateAllKeys.bind(UNDEFINED, EVENT_REVALIDATORS, FOCUS_EVENT)));
      var releaseReconnect_1 = opts.initReconnect(setTimeout.bind(UNDEFINED, revalidateAllKeys.bind(UNDEFINED, EVENT_REVALIDATORS, RECONNECT_EVENT)));
      unmount = function() {
        releaseFocus_1 && releaseFocus_1();
        releaseReconnect_1 && releaseReconnect_1();
        SWRGlobalState.delete(provider);
      };
    }
    return [provider, mutate2, unmount];
  }
  return [provider, SWRGlobalState.get(provider)[4]];
};
var onErrorRetry = function(_, __, config, revalidate, opts) {
  var maxRetryCount = config.errorRetryCount;
  var currentRetryCount = opts.retryCount;
  var timeout = ~~((Math.random() + 0.5) * (1 << (currentRetryCount < 8 ? currentRetryCount : 8))) * config.errorRetryInterval;
  if (!isUndefined(maxRetryCount) && currentRetryCount > maxRetryCount) {
    return;
  }
  setTimeout(revalidate, timeout, opts);
};
var _a = initCache(/* @__PURE__ */ new Map()), cache = _a[0], mutate = _a[1];
var defaultConfig = mergeObjects({
  onLoadingSlow: noop,
  onSuccess: noop,
  onError: noop,
  onErrorRetry,
  onDiscarded: noop,
  revalidateOnFocus: true,
  revalidateOnReconnect: true,
  revalidateIfStale: true,
  shouldRetryOnError: true,
  errorRetryInterval: slowConnection ? 1e4 : 5e3,
  focusThrottleInterval: 5 * 1e3,
  dedupingInterval: 2 * 1e3,
  loadingTimeout: slowConnection ? 5e3 : 3e3,
  compare: function(currentData, newData) {
    return stableHash(currentData) == stableHash(newData);
  },
  isPaused: function() {
    return false;
  },
  cache,
  mutate,
  fallback: {}
}, preset);
var mergeConfigs = function(a, b) {
  var v = mergeObjects(a, b);
  if (b) {
    var u1 = a.use, f1 = a.fallback;
    var u2 = b.use, f2 = b.fallback;
    if (u1 && u2) {
      v.use = u1.concat(u2);
    }
    if (f1 && f2) {
      v.fallback = mergeObjects(f1, f2);
    }
  }
  return v;
};
var SWRConfigContext = createContext({});
var SWRConfig$1 = function(props) {
  var value = props.value;
  var extendedConfig = mergeConfigs(useContext(SWRConfigContext), value);
  var provider = value && value.provider;
  var cacheContext = useState(function() {
    return provider ? initCache(provider(extendedConfig.cache || cache), value) : UNDEFINED;
  })[0];
  if (cacheContext) {
    extendedConfig.cache = cacheContext[0];
    extendedConfig.mutate = cacheContext[1];
  }
  useIsomorphicLayoutEffect(function() {
    return cacheContext ? cacheContext[2] : UNDEFINED;
  }, []);
  return createElement(SWRConfigContext.Provider, mergeObjects(props, {
    value: extendedConfig
  }));
};
var useStateWithDeps = function(state, unmountedRef) {
  var rerender = useState({})[1];
  var stateRef = useRef(state);
  var stateDependenciesRef = useRef({
    data: false,
    error: false,
    isValidating: false
  });
  var setState = useCallback(function(payload) {
    var shouldRerender = false;
    var currentState = stateRef.current;
    for (var _ in payload) {
      var k = _;
      if (currentState[k] !== payload[k]) {
        currentState[k] = payload[k];
        if (stateDependenciesRef.current[k]) {
          shouldRerender = true;
        }
      }
    }
    if (shouldRerender && !unmountedRef.current) {
      rerender({});
    }
  }, []);
  useIsomorphicLayoutEffect(function() {
    stateRef.current = state;
  });
  return [stateRef, stateDependenciesRef.current, setState];
};
var normalize = function(args) {
  return isFunction(args[1]) ? [args[0], args[1], args[2] || {}] : [args[0], null, (args[1] === null ? args[2] : args[1]) || {}];
};
var useSWRConfig = function() {
  return mergeObjects(defaultConfig, useContext(SWRConfigContext));
};
var withArgs = function(hook) {
  return function useSWRArgs() {
    var args = [];
    for (var _i = 0; _i < arguments.length; _i++) {
      args[_i] = arguments[_i];
    }
    var fallbackConfig = useSWRConfig();
    var _a2 = normalize(args), key = _a2[0], fn = _a2[1], _config = _a2[2];
    var config = mergeConfigs(fallbackConfig, _config);
    var next = hook;
    var use = config.use;
    if (use) {
      for (var i = use.length; i-- > 0; ) {
        next = use[i](next);
      }
    }
    return next(key, fn || config.fetcher, config);
  };
};
var subscribeCallback = function(key, callbacks, callback) {
  var keyedRevalidators = callbacks[key] || (callbacks[key] = []);
  keyedRevalidators.push(callback);
  return function() {
    var index = keyedRevalidators.indexOf(callback);
    if (index >= 0) {
      keyedRevalidators[index] = keyedRevalidators[keyedRevalidators.length - 1];
      keyedRevalidators.pop();
    }
  };
};
var WITH_DEDUPE = { dedupe: true };
var useSWRHandler = function(_key, fetcher, config) {
  var cache2 = config.cache, compare = config.compare, fallbackData = config.fallbackData, suspense = config.suspense, revalidateOnMount = config.revalidateOnMount, refreshInterval = config.refreshInterval, refreshWhenHidden = config.refreshWhenHidden, refreshWhenOffline = config.refreshWhenOffline;
  var _a2 = SWRGlobalState.get(cache2), EVENT_REVALIDATORS = _a2[0], STATE_UPDATERS = _a2[1], MUTATION = _a2[2], FETCH = _a2[3];
  var _b = serialize(_key), key = _b[0], fnArgs = _b[1], keyInfo = _b[2];
  var initialMountedRef = useRef(false);
  var unmountedRef = useRef(false);
  var keyRef = useRef(key);
  var fetcherRef = useRef(fetcher);
  var configRef = useRef(config);
  var getConfig = function() {
    return configRef.current;
  };
  var isActive = function() {
    return getConfig().isVisible() && getConfig().isOnline();
  };
  var patchFetchInfo = function(info2) {
    return cache2.set(keyInfo, mergeObjects(cache2.get(keyInfo), info2));
  };
  var cached = cache2.get(key);
  var fallback = isUndefined(fallbackData) ? config.fallback[key] : fallbackData;
  var data = isUndefined(cached) ? fallback : cached;
  var info = cache2.get(keyInfo) || {};
  var error = info.error;
  var isInitialMount = !initialMountedRef.current;
  var shouldRevalidate = function() {
    if (isInitialMount && !isUndefined(revalidateOnMount))
      return revalidateOnMount;
    if (getConfig().isPaused())
      return false;
    if (suspense)
      return isUndefined(data) ? false : config.revalidateIfStale;
    return isUndefined(data) || config.revalidateIfStale;
  };
  var resolveValidating = function() {
    if (!key || !fetcher)
      return false;
    if (info.isValidating)
      return true;
    return isInitialMount && shouldRevalidate();
  };
  var isValidating = resolveValidating();
  var _c = useStateWithDeps({
    data,
    error,
    isValidating
  }, unmountedRef), stateRef = _c[0], stateDependencies = _c[1], setState = _c[2];
  var revalidate = useCallback(function(revalidateOpts) {
    return __awaiter(void 0, void 0, void 0, function() {
      var currentFetcher, newData, startAt, loading, opts, shouldStartNewRequest, isCurrentKeyMounted, cleanupState, newState, finishRequestAndUpdateState, mutationInfo, err_1;
      var _a3;
      return __generator(this, function(_b2) {
        switch (_b2.label) {
          case 0:
            currentFetcher = fetcherRef.current;
            if (!key || !currentFetcher || unmountedRef.current || getConfig().isPaused()) {
              return [2, false];
            }
            loading = true;
            opts = revalidateOpts || {};
            shouldStartNewRequest = !FETCH[key] || !opts.dedupe;
            isCurrentKeyMounted = function() {
              return !unmountedRef.current && key === keyRef.current && initialMountedRef.current;
            };
            cleanupState = function() {
              var requestInfo = FETCH[key];
              if (requestInfo && requestInfo[1] === startAt) {
                delete FETCH[key];
              }
            };
            newState = { isValidating: false };
            finishRequestAndUpdateState = function() {
              patchFetchInfo({ isValidating: false });
              if (isCurrentKeyMounted()) {
                setState(newState);
              }
            };
            patchFetchInfo({
              isValidating: true
            });
            setState({ isValidating: true });
            _b2.label = 1;
          case 1:
            _b2.trys.push([1, 3, , 4]);
            if (shouldStartNewRequest) {
              broadcastState(cache2, key, stateRef.current.data, stateRef.current.error, true);
              if (config.loadingTimeout && !cache2.get(key)) {
                setTimeout(function() {
                  if (loading && isCurrentKeyMounted()) {
                    getConfig().onLoadingSlow(key, config);
                  }
                }, config.loadingTimeout);
              }
              FETCH[key] = [currentFetcher.apply(void 0, fnArgs), getTimestamp()];
            }
            _a3 = FETCH[key], newData = _a3[0], startAt = _a3[1];
            return [4, newData];
          case 2:
            newData = _b2.sent();
            if (shouldStartNewRequest) {
              setTimeout(cleanupState, config.dedupingInterval);
            }
            if (!FETCH[key] || FETCH[key][1] !== startAt) {
              if (shouldStartNewRequest) {
                if (isCurrentKeyMounted()) {
                  getConfig().onDiscarded(key);
                }
              }
              return [2, false];
            }
            patchFetchInfo({
              error: UNDEFINED
            });
            newState.error = UNDEFINED;
            mutationInfo = MUTATION[key];
            if (!isUndefined(mutationInfo) && (startAt <= mutationInfo[0] || startAt <= mutationInfo[1] || mutationInfo[1] === 0)) {
              finishRequestAndUpdateState();
              if (shouldStartNewRequest) {
                if (isCurrentKeyMounted()) {
                  getConfig().onDiscarded(key);
                }
              }
              return [2, false];
            }
            if (!compare(stateRef.current.data, newData)) {
              newState.data = newData;
            } else {
              newState.data = stateRef.current.data;
            }
            if (!compare(cache2.get(key), newData)) {
              cache2.set(key, newData);
            }
            if (shouldStartNewRequest) {
              if (isCurrentKeyMounted()) {
                getConfig().onSuccess(newData, key, config);
              }
            }
            return [3, 4];
          case 3:
            err_1 = _b2.sent();
            cleanupState();
            if (!getConfig().isPaused()) {
              patchFetchInfo({ error: err_1 });
              newState.error = err_1;
              if (shouldStartNewRequest && isCurrentKeyMounted()) {
                getConfig().onError(err_1, key, config);
                if (typeof config.shouldRetryOnError === "boolean" && config.shouldRetryOnError || isFunction(config.shouldRetryOnError) && config.shouldRetryOnError(err_1)) {
                  if (isActive()) {
                    getConfig().onErrorRetry(err_1, key, config, revalidate, {
                      retryCount: (opts.retryCount || 0) + 1,
                      dedupe: true
                    });
                  }
                }
              }
            }
            return [3, 4];
          case 4:
            loading = false;
            finishRequestAndUpdateState();
            if (isCurrentKeyMounted() && shouldStartNewRequest) {
              broadcastState(cache2, key, newState.data, newState.error, false);
            }
            return [2, true];
        }
      });
    });
  }, [key]);
  var boundMutate = useCallback(internalMutate.bind(UNDEFINED, cache2, function() {
    return keyRef.current;
  }), []);
  useIsomorphicLayoutEffect(function() {
    fetcherRef.current = fetcher;
    configRef.current = config;
  });
  useIsomorphicLayoutEffect(function() {
    if (!key)
      return;
    var keyChanged = key !== keyRef.current;
    var softRevalidate = revalidate.bind(UNDEFINED, WITH_DEDUPE);
    var onStateUpdate = function(updatedData, updatedError, updatedIsValidating) {
      setState(mergeObjects({
        error: updatedError,
        isValidating: updatedIsValidating
      }, compare(stateRef.current.data, updatedData) ? UNDEFINED : {
        data: updatedData
      }));
    };
    var nextFocusRevalidatedAt = 0;
    var onRevalidate = function(type) {
      if (type == FOCUS_EVENT) {
        var now = Date.now();
        if (getConfig().revalidateOnFocus && now > nextFocusRevalidatedAt && isActive()) {
          nextFocusRevalidatedAt = now + getConfig().focusThrottleInterval;
          softRevalidate();
        }
      } else if (type == RECONNECT_EVENT) {
        if (getConfig().revalidateOnReconnect && isActive()) {
          softRevalidate();
        }
      } else if (type == MUTATE_EVENT) {
        return revalidate();
      }
      return;
    };
    var unsubUpdate = subscribeCallback(key, STATE_UPDATERS, onStateUpdate);
    var unsubEvents = subscribeCallback(key, EVENT_REVALIDATORS, onRevalidate);
    unmountedRef.current = false;
    keyRef.current = key;
    initialMountedRef.current = true;
    if (keyChanged) {
      setState({
        data,
        error,
        isValidating
      });
    }
    if (shouldRevalidate()) {
      if (isUndefined(data) || IS_SERVER) {
        softRevalidate();
      } else {
        rAF(softRevalidate);
      }
    }
    return function() {
      unmountedRef.current = true;
      unsubUpdate();
      unsubEvents();
    };
  }, [key, revalidate]);
  useIsomorphicLayoutEffect(function() {
    var timer;
    function next() {
      var interval = isFunction(refreshInterval) ? refreshInterval(data) : refreshInterval;
      if (interval && timer !== -1) {
        timer = setTimeout(execute, interval);
      }
    }
    function execute() {
      if (!stateRef.current.error && (refreshWhenHidden || getConfig().isVisible()) && (refreshWhenOffline || getConfig().isOnline())) {
        revalidate(WITH_DEDUPE).then(next);
      } else {
        next();
      }
    }
    next();
    return function() {
      if (timer) {
        clearTimeout(timer);
        timer = -1;
      }
    };
  }, [refreshInterval, refreshWhenHidden, refreshWhenOffline, revalidate]);
  useDebugValue(data);
  if (suspense && isUndefined(data) && key) {
    fetcherRef.current = fetcher;
    configRef.current = config;
    unmountedRef.current = false;
    throw isUndefined(error) ? revalidate(WITH_DEDUPE) : error;
  }
  return {
    mutate: boundMutate,
    get data() {
      stateDependencies.data = true;
      return data;
    },
    get error() {
      stateDependencies.error = true;
      return error;
    },
    get isValidating() {
      stateDependencies.isValidating = true;
      return isValidating;
    }
  };
};
OBJECT.defineProperty(SWRConfig$1, "default", {
  value: defaultConfig
});
var useSWR = withArgs(useSWRHandler);
const RARIBLE_MATCH_RE = /^https:\/\/rarible\.com\/token\/(0x[a-fA-F0-9]{40}):([0-9]+)/;
function isAddress(value) {
  return /^0x[a-fA-F0-9]{40}$/.test(value);
}
function identity(arg) {
  return arg;
}
function parseNftUrl(url2) {
  const raribleMatch = RARIBLE_MATCH_RE.exec(url2);
  if (raribleMatch) {
    return [raribleMatch[1], raribleMatch[2]];
  }
  return null;
}
function fetchImage(src) {
  return new Promise((resolve, reject) => {
    const image = new Image();
    image.src = src;
    image.crossOrigin = "";
    image.onload = () => resolve(image);
    image.onerror = (error) => reject(error);
  });
}
function frameImage(image, { scale = 1, padding = 0 } = {}) {
  const width = image.naturalWidth * scale;
  const height = image.naturalHeight * scale;
  const _padding = Math.max(width * padding, height * padding);
  const canvas = document.createElement("canvas");
  canvas.width = width + _padding * 2;
  canvas.height = height + _padding * 2;
  const ctx = canvas.getContext("2d");
  if (ctx === null) {
    return null;
  }
  ctx.imageSmoothingEnabled = false;
  ctx.drawImage(image, _padding, _padding, width, height);
  return canvas.toDataURL();
}
function ipfsUrlDefault(cid, path = "") {
  return `https://ipfs.io/ipfs/${cid}${path}`;
}
const IPFS_PROTOCOL_RE = /^ipfs:\/\/(?:ipfs\/)?([^/]+)(\/.+)?$/;
const IPFS_HASH_RE = /^Qm[1-9A-HJ-NP-Za-km-z]{44}$/;
function ipfsUrlFromString(ipfsString, ipfsUrl) {
  const ipfsProtocolMatch = IPFS_PROTOCOL_RE.exec(ipfsString);
  if (ipfsProtocolMatch) {
    const [, cid, path = ""] = ipfsProtocolMatch;
    return ipfsUrl(cid, path);
  }
  if (IPFS_HASH_RE.test(ipfsString)) {
    return ipfsUrl(ipfsString);
  }
  return ipfsString;
}
function normalizeOpenSeaUrl(url2, tokenId) {
  try {
    const _url = new URL(url2);
    if (_url.host !== "api.opensea.io" && _url.host !== "testnets-api.opensea.io" || !_url.pathname.includes("0x%7Bid%7D")) {
      return url2;
    }
    _url.pathname = _url.pathname.replace(/0x%7Bid%7D/g, tokenId);
    _url.searchParams.set("format", "json");
    return String(_url);
  } catch (err) {
    return url2;
  }
}
function normalizeNiftyGatewayUrl(url2) {
  try {
    const _url = new URL(url2);
    if (_url.host !== "api.niftygateway.com") {
      return url2;
    }
    _url.pathname = _url.pathname + "/";
    return String(_url);
  } catch (err) {
    return url2;
  }
}
function normalizeTokenUrl(url2, tokenId, fetchContext) {
  url2 = normalizeOpenSeaUrl(url2, tokenId);
  url2 = normalizeNiftyGatewayUrl(url2);
  url2 = ipfsUrlFromString(url2, fetchContext.ipfsUrl);
  if (url2.startsWith("http")) {
    url2 = fetchContext.jsonProxy(url2);
  }
  return url2;
}
function normalizeImageUrl(url2, fetchContext) {
  return ipfsUrlFromString(url2, fetchContext.ipfsUrl);
}
function normalizeNftMetadata(data, fetchContext) {
  return {
    ...data,
    image: normalizeImageUrl(data.image, fetchContext)
  };
}
function fixIncorrectImageField(data) {
  if (!data || typeof data !== "object") {
    return data;
  }
  const _data = data;
  if (typeof _data?.image === "undefined" && typeof _data?.imageUrl === "string") {
    return { ..._data, image: _data?.imageUrl };
  }
  return data;
}
function isNftMetadataMixedInJsonSchema(data) {
  if (!data || typeof data !== "object") {
    return false;
  }
  const _data = data;
  return _data.title === "Asset Metadata" && _data.type === "object" && typeof _data.properties?.name?.description === "string" && typeof _data.properties?.image?.description === "string" && typeof _data.properties?.description?.description === "string" && _data.properties?.name?.type === "string" && _data.properties?.image?.type === "string" && _data.properties?.description?.type === "string";
}
function fixNftMetadataMixedInJsonSchema(data) {
  return {
    name: data.properties?.name?.description || "",
    description: data.properties?.description?.description || "",
    image: data.properties?.image?.description || "",
    rawData: { ...data }
  };
}
function isNftMetadata(data) {
  if (!data || typeof data !== "object") {
    return false;
  }
  const _data = data;
  return "name" in _data || "image" in _data;
}
function addressesEqual(addr1, addr2) {
  return addr1?.toLowerCase() === addr2?.toLowerCase();
}
function promiseAny(promises) {
  return reversePromise(Promise.all([...promises].map(reversePromise)));
}
function reversePromise(promise) {
  return new Promise((resolve, reject) => {
    Promise.resolve(promise).then(reject, resolve);
  });
}
class MultipleErrors extends Error {
  constructor(message, errors) {
    super(message);
    this.name = "MultipleErrors";
    this.errors = errors;
  }
}
const IMAGE_EXT_RE = /\.(?:png|svg|jpg|jepg|gif|webp|jxl|avif)$/;
const VIDEO_EXT_RE = /\.(?:mp4|mov|webm|ogv)$/;
function urlExtensionType(url2) {
  if (IMAGE_EXT_RE.test(url2))
    return "image";
  if (VIDEO_EXT_RE.test(url2))
    return "video";
  return "unknown";
}
const CRYPTOKITTIES = "0x06012c8cf97BEaD5deAe237070F9587f8E7A266d";
const CRYPTOPUNKS = "0xb47e3cd837ddf8e4c57f05d70ab865de6e193bbb";
const CRYPTOPUNKS_IMAGES = "0x16F5A35647D6F03D5D3da7b35409D65ba03aF3B2";
const DECENTRALAND_ESTATE = "0x959e104E1a4dB6317fA58F8295F586e1A978c297";
const DECENTRALAND_PARCEL = "0xf87e31492faf9a91b02ee0deaad50d51d56d5d4d";
const CRYPTOPUNKS_DESCRIPTION = `
  10,000 unique collectible characters with proof of ownership stored on the
  Ethereum blockchain. The project that inspired the modern CryptoArt movement.
  The first "Non-Fungible Token," and inspiration for the Ethereum ERC-721
  standard that powers most digital art and collectibles.
`;
const CRYPTOPUNKS_IMAGE_SVG = {
  address: CRYPTOPUNKS_IMAGES,
  methodName: "punkImageSvg",
  methodHash: "0x74beb047",
  humanReadableAbi: [
    "function punkImageSvg(uint16 index) view returns (string svg)"
  ]
};
function encodeUriData(dataUri) {
  const dataStart = dataUri.indexOf(",") + 1;
  return dataUri.slice(0, dataStart) + encodeURIComponent(dataUri.slice(dataStart));
}
async function cryptoPunksMetadata(index, cryptoPunksImage2) {
  const image = await cryptoPunksImage2(index, CRYPTOPUNKS_IMAGE_SVG);
  return {
    description: CRYPTOPUNKS_DESCRIPTION,
    image: encodeUriData(image),
    imageType: "image",
    metadataUrl: "",
    name: `CryptoPunk ${index}`,
    owner: "",
    rawData: null
  };
}
function isCryptoPunks(contractAddress) {
  return addressesEqual(contractAddress, CRYPTOPUNKS);
}
async function cryptoKittiesMetadata(id, { jsonProxy }) {
  const metadataUrl = jsonProxy(`https://api.cryptokitties.co/v3/kitties/${id}`);
  const res = await fetch(metadataUrl);
  const data = await res.json();
  const image = data?.image_url ?? "";
  return {
    description: data?.bio ?? "\u2212",
    image,
    imageType: image ? "image" : "unknown",
    metadataUrl,
    name: data?.name ?? "Unknown",
    owner: "",
    rawData: data
  };
}
function isCryptoKitties(contractAddress) {
  return addressesEqual(contractAddress, CRYPTOKITTIES);
}
const ENDPOINT$1 = "https://api.thegraph.com/subgraphs/name/decentraland/marketplace";
const QUERY$1 = `
  query NFTByTokenId($contractAddress: String, $tokenId: String) {
    nfts(
      where: { contractAddress: $contractAddress, tokenId: $tokenId }
      first: 1
    ) {
      name
      image
      owner {
        address
      }
      estate {
        size
        data {
          description
        }
      }
    }
  }
`;
function body$1(contractAddress, tokenId) {
  return JSON.stringify({
    operationName: "NFTByTokenId",
    variables: { contractAddress, tokenId },
    query: QUERY$1
  });
}
async function decentralandEstateMetadata(tokenId) {
  const response = await fetch(ENDPOINT$1, {
    body: body$1(DECENTRALAND_ESTATE, tokenId),
    method: "POST"
  });
  const { data } = await response.json();
  const nft = data?.nfts?.[0];
  const image = nft?.image ?? "";
  return {
    description: nft?.estate?.data?.description ?? "\u2212",
    image,
    imageType: image ? "image" : "unknown",
    metadataUrl: "",
    name: nft?.name ?? "Unknown",
    owner: nft?.owner?.address ?? "",
    rawData: data
  };
}
function isDecentralandEstate(contractAddress) {
  return addressesEqual(contractAddress, DECENTRALAND_ESTATE);
}
const ENDPOINT = "https://api.thegraph.com/subgraphs/name/decentraland/marketplace";
const QUERY = `
  query NFTByTokenId($contractAddress: String, $tokenId: String) {
    nfts(
      where: { contractAddress: $contractAddress, tokenId: $tokenId }
      first: 1
    ) {
      name
      image
      owner {
        address
      }
      parcel {
        x
        y
        data {
          description
        }
      }
    }
  }
`;
function body(contractAddress, tokenId) {
  return JSON.stringify({
    operationName: "NFTByTokenId",
    variables: { contractAddress, tokenId },
    query: QUERY
  });
}
async function decentralandParcelMetadata(tokenId) {
  const response = await fetch(ENDPOINT, {
    body: body(DECENTRALAND_PARCEL, tokenId),
    method: "POST"
  });
  const { data } = await response.json();
  const nft = data?.nfts?.[0];
  const parcel = nft?.parcel;
  const image = nft?.image ?? "";
  return {
    description: parcel?.data?.description ?? "-",
    image,
    imageType: image ? "image" : "unknown",
    metadataUrl: "",
    name: nft?.name ?? `Parcel ${parcel?.x},${parcel?.y}`,
    owner: nft?.owner?.address ?? "",
    rawData: data
  };
}
function isDecentralandParcel(contractAddress) {
  return addressesEqual(contractAddress, DECENTRALAND_PARCEL);
}
const MOONCATS_WRAPPED = {
  address: "0x7c40c393dc0f283f318791d746d894ddd3693572",
  methodName: "_tokenIDToCatID",
  methodHash: "0xfe294644",
  humanReadableAbi: [
    "function _tokenIDToCatID(uint256 tokenId) view returns (bytes5 catId)"
  ]
};
const MOONCATS_IPFS_CID = "bafybeidk4zunuq56w2pf2sncexohlyqae62dzplljkbwswa7jwywh2dava";
async function imageUrl(catId, ipfsUrl) {
  const dir = catId.slice(4, 6);
  const url2 = ipfsUrlFromString(`ipfs://ipfs/${MOONCATS_IPFS_CID}/${dir}/${catId}.png`, ipfsUrl);
  const image = await fetchImage(url2);
  return frameImage(image, { scale: 4, padding: 0.125 });
}
async function moonCatsMetadata(tokenId, getCatId, fetchContext) {
  const catId = await getCatId(tokenId, MOONCATS_WRAPPED);
  const image = await imageUrl(catId, fetchContext.ipfsUrl) ?? "";
  return {
    description: `The (unofficial) wrapped version of MoonCats Rescue. Original cat ID: ${catId}.`,
    image,
    imageType: image ? "image" : "unknown",
    metadataUrl: "",
    name: `Wrapped MoonCat #${tokenId}`,
    owner: "",
    rawData: null
  };
}
function isMoonCats(contractAddress) {
  return addressesEqual(contractAddress, MOONCATS_WRAPPED.address);
}
function cryptoPunksImage$1(config) {
  return async function cryptoPunksImage2(index, method) {
    const contract = new config.ethers.Contract(method.address, method.humanReadableAbi, config.provider);
    return contract.punkImageSvg(index);
  };
}
function moonCatsCatId$1(config) {
  return async function moonCatsCatId2(tokenId, method) {
    const wrappedContract = new config.ethers.Contract(method.address, method.humanReadableAbi, config.provider);
    const result = await wrappedContract._tokenIDToCatID(tokenId);
    return result ?? "";
  };
}
async function fetchMetadata(url2, fetchContext) {
  const res = await fetch(url2);
  if (!res.ok) {
    throw new Error("Error when trying to request " + url2);
  }
  let rawData;
  try {
    rawData = await res.json();
  } catch (err) {
    rawData = { name: "", description: "", image: url2 };
  }
  let data = { ...rawData };
  if (isNftMetadataMixedInJsonSchema(data)) {
    data = fixNftMetadataMixedInJsonSchema(data);
  }
  data = fixIncorrectImageField(data);
  if (!isNftMetadata(data)) {
    throw new Error("Invalid data received");
  }
  return normalizeNftMetadata({
    description: data.description || "",
    image: data.image || "",
    name: data.name || "",
    rawData
  }, fetchContext);
}
const ABI = [
  "function tokenURI(uint256 _tokenId) external view returns (string)",
  "function ownerOf(uint256 _tokenId) external view returns (address)",
  "function uri(uint256 _id) external view returns (string)"
];
async function url$1(contract, tokenId, fetchContext) {
  const uri = await promiseAny([
    contract.tokenURI(tokenId),
    contract.uri(tokenId)
  ]).catch((errors) => {
    throw new MultipleErrors("An error occurred while trying to fetch the token URI from the NFT contract. See the \u201Cerrors\u201D property on this error for details.", errors);
  });
  return normalizeTokenUrl(uri, tokenId, fetchContext);
}
async function fetchStandardNftContractData$1(contractAddress, tokenId, config, fetchContext) {
  const contract = new config.ethers.Contract(contractAddress, ABI, config.provider);
  const [metadataUrl, owner] = await Promise.all([
    url$1(contract, tokenId, fetchContext),
    contract.ownerOf(tokenId).catch(() => "")
  ]);
  const metadata = await fetchMetadata(metadataUrl, fetchContext);
  const imageType = urlExtensionType(metadata.image);
  return {
    ...metadata,
    imageType,
    metadataUrl,
    owner
  };
}
const ETHERS_NOT_FOUND = "Ethers couldn\u2019t be imported. Please add the ethers module to your project dependencies, or inject it in the Ethers fetcher options.";
async function loadEthers(config) {
  if (config.ethers?.Contract) {
    return config;
  }
  try {
    const ethers = await import("./index.js").then((m) => m?.default ?? m);
    if (!ethers?.Contract) {
      throw new Error();
    }
    return { ...config, ethers };
  } catch (err) {
    throw new Error(ETHERS_NOT_FOUND);
  }
}
async function fetchNftMetadata$1(contractAddress, tokenId, config, fetchContext) {
  if (isDecentralandParcel(contractAddress)) {
    return decentralandParcelMetadata(tokenId);
  }
  if (isDecentralandEstate(contractAddress)) {
    return decentralandEstateMetadata(tokenId);
  }
  if (isCryptoKitties(contractAddress)) {
    return cryptoKittiesMetadata(tokenId, fetchContext);
  }
  const configWithEthersLoaded = await loadEthers(config);
  if (isCryptoPunks(contractAddress)) {
    return cryptoPunksMetadata(tokenId, cryptoPunksImage$1(configWithEthersLoaded));
  }
  if (isMoonCats(contractAddress)) {
    return moonCatsMetadata(tokenId, moonCatsCatId$1(configWithEthersLoaded), fetchContext);
  }
  return fetchStandardNftContractData$1(contractAddress, tokenId, configWithEthersLoaded, fetchContext);
}
function addProxyImage$1(metadata, imageProxy) {
  return metadata.image.startsWith("http") ? { ...metadata, image: imageProxy(metadata.image, metadata) } : metadata;
}
function ethersFetcher(config) {
  return {
    config,
    async fetchNft(contractAddress, tokenId, fetchContext) {
      if (!isAddress(contractAddress)) {
        throw new Error(`Invalid contract address: ${contractAddress}`);
      }
      const metadata = await fetchNftMetadata$1(contractAddress, tokenId, config, fetchContext);
      return addProxyImage$1(metadata, fetchContext.imageProxy);
    }
  };
}
const URI_METHOD_ERC721 = "0xc87b56dd";
const URI_METHOD_ERC1155 = "0x0e89341c";
const OWNER_OF_METHOD_ERC721 = "0x6352211e";
function uint256Hex(value) {
  let result = "";
  for (let i = 0; i < 32; ++i) {
    result += ("0" + (value >> BigInt(8 * 32 - i * 8 - 8) & BigInt(255)).toString(16)).slice(-2);
  }
  return result;
}
function bytesToBigInt(bytes) {
  let value = BigInt(0);
  for (const byte of bytes) {
    value = (value << BigInt(8)) + BigInt(byte);
  }
  return value;
}
function hexToUint8Array(hex) {
  hex = hex.replace(/^0x/, "");
  return new Uint8Array((hex.match(/.{1,2}/g) ?? []).map((byte) => parseInt(byte, 16)));
}
function decodeString(hex) {
  const data = hexToUint8Array(hex);
  const pointer = Number(bytesToBigInt(data.subarray(0, 32)));
  const length = Number(bytesToBigInt(data.subarray(pointer, pointer + 32)));
  const bytes = data.subarray(pointer + 32, pointer + 32 + length);
  return new TextDecoder().decode(bytes);
}
function decodeAddress(hex) {
  const data = hexToUint8Array(hex);
  const bytes = data.subarray(0, 32);
  const decoded = bytesToBigInt(bytes);
  if (decoded >= BigInt(2) ** BigInt(160))
    throw new Error(`Encoded value is bigger than the largest possible address.  Decoded value: 0x${decoded.toString(16)}.`);
  return `0x${decoded.toString(16)}`;
}
function methodUriErc721(tokenId) {
  return URI_METHOD_ERC721 + uint256Hex(tokenId);
}
function methodUriErc1155(id) {
  return URI_METHOD_ERC1155 + uint256Hex(id);
}
function methodOwnerOfErc721(tokenId) {
  return OWNER_OF_METHOD_ERC721 + uint256Hex(tokenId);
}
function ethCall(ethereum, to, data) {
  return ethereum.request({
    method: "eth_call",
    params: [{ data, to }, "latest"]
  });
}
function cryptoPunksImage(config) {
  return async function cryptoPunksImage2(index, method) {
    if (config.ethereum === void 0) {
      throw new Error("No Ethereum provider");
    }
    return ethCall(config.ethereum, method.address, method.methodHash + uint256Hex(BigInt(index))).then(decodeString);
  };
}
function moonCatsCatId(config) {
  return async function moonCatsCatId2(tokenId, method) {
    if (config.ethereum === void 0) {
      throw new Error("No Ethereum provider");
    }
    const result = await ethCall(config.ethereum, method.address, method.methodHash + uint256Hex(BigInt(tokenId)));
    return result.slice(0, 12);
  };
}
function uriMethods(tokenId) {
  return [methodUriErc721(BigInt(tokenId)), methodUriErc1155(BigInt(tokenId))];
}
async function url(contractAddress, tokenId, ethereum, fetchContext) {
  const uri = await promiseAny(uriMethods(tokenId).map((method) => ethCall(ethereum, contractAddress, method))).catch((errors) => {
    throw new MultipleErrors("An error occurred while trying to fetch the token URI from the NFT contract. See the \u201Cerrors\u201D property on this error for details.", errors);
  });
  return normalizeTokenUrl(decodeString(uri), tokenId, fetchContext);
}
async function fetchStandardNftContractData(contractAddress, tokenId, { ethereum }, fetchContext) {
  const [metadataUrl, owner] = await Promise.all([
    url(contractAddress, tokenId, ethereum, fetchContext),
    ethCall(ethereum, contractAddress, methodOwnerOfErc721(BigInt(tokenId))).then(decodeAddress).catch(() => "")
  ]);
  const metadata = await fetchMetadata(metadataUrl, fetchContext);
  const imageType = urlExtensionType(metadata.image);
  return {
    ...metadata,
    imageType,
    metadataUrl,
    owner
  };
}
async function fetchNftMetadata(contractAddress, tokenId, config, fetchContext) {
  if (isDecentralandParcel(contractAddress)) {
    return decentralandParcelMetadata(tokenId);
  }
  if (isDecentralandEstate(contractAddress)) {
    return decentralandEstateMetadata(tokenId);
  }
  if (isCryptoKitties(contractAddress)) {
    return cryptoKittiesMetadata(tokenId, fetchContext);
  }
  if (isCryptoPunks(contractAddress)) {
    return cryptoPunksMetadata(tokenId, cryptoPunksImage(config));
  }
  if (isMoonCats(contractAddress)) {
    return moonCatsMetadata(tokenId, moonCatsCatId(config), fetchContext);
  }
  return fetchStandardNftContractData(contractAddress, tokenId, config, fetchContext);
}
function addProxyImage(metadata, imageProxy) {
  return metadata.image.startsWith("http") ? { ...metadata, image: imageProxy(metadata.image, metadata) } : metadata;
}
function normalizeConfig(config) {
  if (!config.ethereum) {
    if (window.ethereum) {
      config.ethereum = window.ethereum;
    } else {
      throw new Error("Missing ethereum provider.");
    }
  }
  return config;
}
function ethereumFetcher(config) {
  const _config = normalizeConfig(config);
  return {
    config: _config,
    async fetchNft(contractAddress, tokenId, fetchContext) {
      if (!isAddress(contractAddress)) {
        throw new Error(`Invalid contract address: ${contractAddress}`);
      }
      const metadata = await fetchNftMetadata(contractAddress, tokenId, _config, fetchContext);
      return addProxyImage(metadata, fetchContext.imageProxy);
    }
  };
}
const NFT_METADATA_DEFAULT$1 = {
  name: "",
  description: "",
  image: ""
};
function isFetcherDeclarationEthers(fetcher) {
  return Array.isArray(fetcher) && fetcher.length == 2 && fetcher[0] === "ethers";
}
function isFetcherDeclarationEthereum(fetcher) {
  return Array.isArray(fetcher) && fetcher.length == 2 && fetcher[0] === "ethereum";
}
function normalizeFetcher(fetcher) {
  if (isFetcherDeclarationEthers(fetcher)) {
    return ethersFetcher(fetcher[1]);
  }
  if (isFetcherDeclarationEthereum(fetcher)) {
    return ethereumFetcher(fetcher[1]);
  }
  return fetcher;
}
const NftContext = createContext(null);
const NftProvider = function NftProvider2({
  children,
  fetcher,
  imageProxy = identity,
  ipfsUrl = ipfsUrlDefault,
  jsonProxy = identity
}) {
  if (!fetcher) {
    throw new Error("Please set the fetcher prop on <NftProvider />");
  }
  const context = {
    fetcher: normalizeFetcher(fetcher),
    imageProxy,
    ipfsUrl,
    jsonProxy
  };
  return /* @__PURE__ */ React.createElement(NftContext.Provider, {
    value: context
  }, children);
};
function useNft(contractAddress, tokenId) {
  const context = useContext(NftContext);
  if (context === null) {
    throw new Error("Please wrap your app with <NftProvider />");
  }
  const { fetcher, imageProxy, ipfsUrl, jsonProxy } = context;
  const fetchContext = useMemo(() => ({ imageProxy, ipfsUrl, jsonProxy }), [imageProxy, ipfsUrl, jsonProxy]);
  const fetchNft = useCallback(async () => {
    return fetcher ? fetcher.fetchNft(contractAddress, tokenId, fetchContext) : { ...NFT_METADATA_DEFAULT$1 };
  }, [contractAddress, fetcher, fetchContext, tokenId]);
  const result = useSWR(contractAddress + tokenId, fetchNft, {
    revalidateOnFocus: false,
    revalidateOnReconnect: false
  });
  return useMemo(() => {
    const { error, data, mutate: mutate2 } = result;
    const reload = () => mutate2().then(() => true).catch(() => false);
    if (error === void 0 && data === void 0) {
      return {
        error: void 0,
        loading: true,
        nft: void 0,
        reload,
        status: "loading"
      };
    }
    if (error !== void 0) {
      return {
        error,
        loading: false,
        nft: void 0,
        reload,
        status: "error"
      };
    }
    return {
      error: void 0,
      loading: false,
      nft: data,
      reload,
      status: "done"
    };
  }, [result]);
}
const NFT_METADATA_DEFAULT = {
  name: "",
  description: "",
  image: ""
};
class FetchWrapper {
  constructor(fetcher, options = {}) {
    this.fetcher = this.normalizeFetcher(fetcher);
    this.fetchContext = this.fetchContextFromOptions(options);
  }
  fetchContextFromOptions({
    imageProxy,
    ipfsUrl,
    jsonProxy
  }) {
    return {
      imageProxy: imageProxy ?? identity,
      ipfsUrl: ipfsUrl ?? ipfsUrlDefault,
      jsonProxy: jsonProxy ?? identity
    };
  }
  normalizeFetcher(fetcher) {
    if (!fetcher) {
      return {
        config: {},
        fetchNft: () => Promise.resolve(NFT_METADATA_DEFAULT)
      };
    }
    if (this.isFetcherDeclarationEthers(fetcher)) {
      return ethersFetcher(fetcher[1]);
    }
    if (this.isFetcherDeclarationEthereum(fetcher)) {
      return ethereumFetcher(fetcher[1]);
    }
    return fetcher;
  }
  isFetcherDeclarationEthers(fetcher) {
    return Array.isArray(fetcher) && fetcher.length == 2 && fetcher[0] === "ethers";
  }
  isFetcherDeclarationEthereum(fetcher) {
    return Array.isArray(fetcher) && fetcher.length == 2 && fetcher[0] === "ethereum";
  }
  async fetchNft(contractAddress, tokenId) {
    return await this.fetcher.fetchNft(contractAddress, tokenId, this.fetchContext);
  }
}
export { FetchWrapper, NftProvider, ethereumFetcher, ethersFetcher, parseNftUrl, useNft };
//# sourceMappingURL=use-nft.es.js.map
